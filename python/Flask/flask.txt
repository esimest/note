flask程序基本结构
app = Flask(__name__) __name__一般指代程序包的名称，也是查找程序资源的入口
初始化一个Flask实例。通过该实例接受客户端的请求。并作出响应
客户端请求通过路由找到对应的视图函数，视图函数对请求处理过后，返回一个响应给客户端

HTTP请求发送到服务器
服务器将请求转交给Flask实例。这时请求应该改是一个对象
flask使用上下文让特定的对象在一个线程中全局可以访问

Flask在请求分发之前 激活程序和请求上下文。处理结束后(返回响应)删除
app_ctx=app.app_context()#获取上下文
app_ctx.push() 推送（激活）上下文。之后就可以使用上下文变量

当Flask APP读入配置并启动时current_app,g两个上下文变量就生效了，程序结束后失效
当一个请求被处理时，request,session两个上下文就生效了，返回响应后失效

请求钩子（装饰器）。注册一个函数使其在特定时间起作用
before_first_request
before_request
after_request
teardown_request。即使有为处理的异常抛出，每次请求处后也要执行

重定向时一种响应类型。flask 使用 redirect(url)生成这种响应类型
abort(status_code) 用于生生错误响应
url_for()重新生成一个url,render_template获取url指定的模板
url_for(view_function,arguemnts)
url_for('static',filename = )

flask使用render_template将jinja2模板引擎集成到程序中
@app.errorhandler(404/403/500...)
def 

使用程序工厂函数
正常情况下Flask程序实例在运行脚本的同时创建
把创建实例的过程迁移至可显式调用的工厂函数中，可自决定创建实例的时间

蓝本中的路由处于休眠状态，知道被Flask注册后，才真正成为程序的一部分
生成依赖文件
pip freeze >requirements.txt