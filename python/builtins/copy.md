# Python 拷贝

## == 和 is

一般情况下对象的比较都用 == ，当和单例对象进行比较是多用 is 如 None, True, False

> is 是 == 的特殊情况，当且仅当两个变量 a,b 符合 id(a) == id(b) 则 (a is b) 为真
> 等价与 变量 a,b 指向同一个对象的时候 a is b
> a == b 是 a.__eq__(b) 的另一种写法

```python
a = obj
b = obj

# id 函数，返回变量所指向的对象的地址

# 由于 python 内部维护了一个 -5 ~ 256 的整形数组，每次访问这个范围内的数字时都会返回对应数字的索引。所以 a = 1, b = 1 ==> id(a) == id(b)
In [16]: a, b = 1, 1

In [17]: id(a), id(b)
Out[17]: (1784010928, 1784010928)

In [26]: a, b = 257, 257

In [27]: id(a), id(b)
Out[27]: (85027808, 82616192)

In [18]: c, d = {1}, {1}

In [19]: id(c), id(d)
Out[19]: (85070952, 86872112)

In [21]: id(e), id(f)
Out[21]: (89652240, 89537072)
# 两个相同的字符串的内存地址是相同的
In [23]: g, h = "hello", "hello"

In [24]: g is h
Out[24]: True

In [25]: id(g), id(h)
Out[25]: (86096960, 86096960)
```

## 深浅拷贝

> 深浅拷贝的不同只会体现在 compound object(混合对象，包含其它对象的对象) 上

### 浅拷贝

对对象 a 的浅拷贝所执行的操作为:
创建一个 type(a) 的实例 b ，b 的元素为 a 的元素的引用

```python
# 集中可以完成浅拷贝的操作

# 1. 类的构造方法
a = Obj(*args, **kwargs)
b = Obj(a)

# 2. 可变序列的切片操作
a = [1, 2, 3]
b = a[:]

# 3. copy.copy
a = Obj(*args, **kwargs)
b = copy.copy(a)
```

### 深拷贝

> 浅拷贝的问题在与，浅拷贝与原对象使用的是内存里的同一份数据。因此会导致数据在不知情的情况下被修改

深拷贝:
创建一个对象的深拷贝是通过创建一个新对象，然后递归的对子对象进行拷贝操作。
因此：深拷贝与原对象物理上没有任何关系

深拷贝的问题:
深拷贝使用的是递归的方式对原对象的子对象进行拷贝，因此会造成循环拷贝的现象

> 深拷贝可以通过 copy.deepcopy() 来实现
