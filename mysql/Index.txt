顺序读（逻辑上）：按地址顺序读取磁盘上的块（根据索引叶节点数据就能读出所需行的数据）
随机读：访问的块不连续（访问叶节点数据无法直接得到行数据）
为了提高随机读的性能，使用预读取（一次I/O请求多个页，并估计这些预读取的页马上就要被访问）
随机预读取：当一个区的13个页（顺序随机）在缓存区中，就会将剩下的页全部读入缓存区
线性预读取：一个区中24个页都被顺序读取时，将其它页全部读入缓存

磁盘利用率：磁盘活动时间百分比
索引过多会影响{应用}的性能，过少会影响{查询}的性能
mysql中每张表必须有一个主健（聚集索引）。但对于大表来说，一个索引往往是不够的

B+树=B树+ISAM（索引顺序访问）
B+树的记录点（数据）按顺序的存放在同一层的叶节点中，

InnoDB表是索引组织表
聚集索引的叶节点存放的数据页（每张表只能拥有一个聚集索引）
每个数据页通过双向链表进行链接（与页内数据链接方式一样）
block/page 是数据库中最小的存储以及处理单元。因此通过索引查找获取的是，该索引指向的行所在的页，将页加载到内存后才能继续查找得到对应的行。
为了保持B+树的平衡，对于新插入的数据可能需要大量的拆分页操作，B+树主要用于磁盘，因此拆分页意味着磁盘操作。
B+树索引分为聚集索引与非聚集索引。结构都是B+树，区别在与，叶节点存放的数据是否是一整行的数据
聚集索引页子节点中存放的是带有完整行数据的页
聚集索引对于主键的排序查找和范围查找很快

SQLSERVER的表类型是 堆表 索引组织表
堆表的索引是非聚集的，堆表没有逐渐。此时书签通过记录对应行的标识符来定位实际的行。
当发生更新操作时，可能要修改标识符。开销会很大（适合OLAP）

非聚集索引的离散读

ALTER TABLE ADD|DROP INDEX 

CREATE INDEX ON
DROP INDEX ON
索引可以索引整个列的数据，也可索引列的开头部分数据

mysql实现添加或删除索引的方式是，先rename,然后重建表结构，最后导入
辅助索引有一种快速创建的方式。对表加S锁，然后建索引。（此时表只读）
SHOW INDEX


使用B+树索引的情况：
访问表中很少一部分行时（即字段值重复少），访问量高
对于重复值多的字段，mysql会进行全表扫描（20%）

非聚集索引叶节点存放的是一个记录对应行的主键值的书签。然后通过主键的值对B+树进行顺序查找找到对应的行所在的页。
联合索引还是一颗B+树，只是节点的键值由多个键组成
